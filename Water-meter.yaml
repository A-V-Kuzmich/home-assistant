esphome:
  name: water-meter
  friendly_name: Water-meter

esp8266: # chose your bord
  board: esp01_1m 

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "Pyq...." # add your key

ota:
  - platform: esphome
    password: "d4...." # add your pass

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Water-Meter Fallback Hotspot"
    password: "ha...." # add your pass

captive_portal:

globals:
  - id: empty_distance
    type: float
    initial_value: '1.45'  # m — empty tank, distance from the sensor to the minimum level of possible water intake (pipes)
  - id: calibration_work_distance
    type: float
    initial_value: '0.20'  # m - is the correction factor, the distance from the sensor to the water mirror
  - id: radius
    type: float
    initial_value: '0.3'  # m -  is the radius of the tub
  - id: calibration_factor
    type: float
    initial_value: '0.01'  # m -  is the calibration coefficient of the sensor

  - id: timeout_counter
    type: int
    initial_value: '0'

  - id: total_timeouts
    type: int
    initial_value: '0'
    restore_value: yes

  - id: last_timeout_at_uptime
    type: float
    initial_value: '-1'
    restore_value: yes

sensor:
  - platform: ultrasonic
    id: distance_sensor
    name: "distance"
    unit_of_measurement: "m"
    update_interval: 5s
    trigger_pin: 5
    echo_pin: 4
    filters:
      - median:
          window_size: 5
          send_every: 2
          send_first_at: 1
          - lambda: |-
          if (isnan(x)) {
            id(timeout_counter)++;
            id(total_timeouts)++;
            id(last_timeout_at_uptime) = id(uptime_sensor).state;

            ESP_LOGW("distance_raw", "Timeouts: %d | Total: %d", id(timeout_counter), id(total_timeouts));

            if (id(timeout_counter) > 20) {
              ESP_LOGE("distance_raw", "TOO MANY TIMEOUTS — RESTARTING ESP!");
              ESP.restart();
            }
            return NAN;
          }
          id(timeout_counter) = 0;

          ESP_LOGI("distance_raw", "RAW DISTANCE = %.5f m", x);

          float corrected = x + id(calibration_factor);
          return corrected;
      - delta: 0.01
      - round: 2
    on_value:
      then:
        - lambda: |-
            float d = id(distance_sensor).state;
            if (isnan(d)) {
              id(liters_sensor).publish_state(0);
              id(percent_sensor).publish_state(0);
              return;
            }

            float work_zone = id(empty_distance) - id(calibration_work_distance);
            float radius_squared = id(radius) * id(radius);
            float level = work_zone - (d - id(calibration_work_distance));
            float volume_m3 = 3.14 * radius_squared * level;
            float percent = ((id(empty_distance) - d) / work_zone) * 100.0;

            if (percent < 0) percent = 0;

            id(liters_sensor).publish_state(volume_m3 * 1000.0);
            id(percent_sensor).publish_state(percent);

    
  - platform: template
    id: liters_sensor
    name: "Liters"
    unit_of_measurement: "л"
    accuracy_decimals: 1
    icon: "mdi:barrel"
    update_interval: never  # <-- does not update itself

  - platform: template
    id: percent_sensor
    name: "%"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:water-percent"
    update_interval: never # <-- does not update itself

# logs:
  - platform: uptime
    id: uptime_sensor
    update_interval: 5s
    
  - platform: template
    id: uptime_minutes
    name: "Uptime (min)"
    unit_of_measurement: "min"
    lambda: |-
      return id(uptime_sensor).state / 60.0;

  - platform: template
    id: minutes_since_last_timeout
    name: "Minutes since last timeout"
    unit_of_measurement: "min"
    update_interval: 30s
    lambda: |-
      if (id(last_timeout_at_uptime) < 0) return -1;
      float diff = (id(uptime_sensor).state - id(last_timeout_at_uptime)) / 60.0;
      return diff;

  - platform: template
    id: timeout_rate
    name: "Timeouts per hour avg"
    unit_of_measurement: "timeout/h"
    update_interval: 60s
    lambda: |-
      float hours = id(uptime_sensor).state / 3600.0;
      if (hours < 0.01) return 0;
      return id(total_timeouts) / hours;
